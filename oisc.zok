// TODO: make this using fields instead of u32

struct Memory {
	u32[64] values
}

struct State {
	Memory memory
	u32 pc
	bool running
	u32[16] output
	u32 output_len
}

// NOTE: ensure it matches the above struct
const u32 MEMORY_SIZE = 64
const u32 OUTPUT_SIZE = 16
// The hardcoded execution step limit
const u32 STEP_LIMIT = 2

def main(Memory init) -> State:
	State s = State {
		memory: init,
		pc: 0,
		running: true,
		output: [0; OUTPUT_SIZE],
		output_len: 0,
	}
	for u32 step in 0..STEP_LIMIT do
		// Note, due to checking s.running in every state modifying part,
		// the below code will keep "applying" the same last step from
		// the point it has been srtopped, until STEP_LIMIT.

		u32 a = s.memory.values[s.pc]
		u32 b = s.memory.values[s.pc + 1]
		u32 c = s.memory.values[s.pc + 2]

		// This is the special case
		bool syscall = (a == 4294967295)
		// stop() syscall
		s.running = !(syscall && c == 0)
		// put() syscall
		s.output[s.output_len] = s.memory.values[b]
		s.output_len = if (s.running && syscall && c == 1) then (s.output_len + 1) else s.output_len fi

		// This is the regular codepath
		u32 a_prime = s.memory.values[a] - s.memory.values[b]
		bool cond = s.memory.values[a] <= s.memory.values[b]

		s.pc = if (s.running && (syscall || !cond)) then c else (s.pc + 3) fi
		s.memory.values[a] = if (s.running && !syscall) then a_prime else s.memory.values[a] fi
	endfor

	return s
